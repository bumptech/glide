package com.bumptech.glide.annotation.ksp

import com.bumptech.glide.annotation.GlideModule
import com.bumptech.glide.annotation.ksp.LibraryGlideModuleData.LibraryModuleName
import com.google.devtools.ksp.processing.SymbolProcessorEnvironment
import com.google.devtools.ksp.symbol.KSClassDeclaration
import com.google.devtools.ksp.symbol.KSFile
import com.squareup.kotlinpoet.AnnotationSpec
import com.squareup.kotlinpoet.DelicateKotlinPoetApi
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.TypeSpec
import java.util.UUID

internal data class LibraryGlideModuleData(
  val name: LibraryModuleName,
  val containingFile: KSFile?,
) {
  data class LibraryModuleName(val qualifiedName: String)
}

internal class LibraryGlideModulesParser(
  private val environment: SymbolProcessorEnvironment,
  private val libraryGlideModules: List<KSClassDeclaration>,
) {
  init {
    require(libraryGlideModules.isNotEmpty())
  }

  fun parseUnique(): List<LibraryGlideModuleData> {
    val allLibraryGlideModules =
      libraryGlideModules
        .map {
          LibraryGlideModuleData(
            LibraryModuleName(it.qualifiedName!!.asString()),
            it.containingFile
          )
        }
        .toList()
    val uniqueLibraryGlideModules = allLibraryGlideModules.associateBy { it.name }.values.toList()
    if (uniqueLibraryGlideModules.size != libraryGlideModules.size) {
      // Find the set of modules that have been included more than once by mapping the qualified
      // name of the module to a count of the number of times it's been seen. Duplicates are then
      // any keys that have a value > 1.
      val duplicateModules: List<String> =
        allLibraryGlideModules
          .groupingBy { it.name.qualifiedName }
          .eachCount()
          .filter { it.value > 1 }
          .keys
          .toList()
      environment.logger.warn(
        GlideSymbolProcessorConstants.DUPLICATE_LIBRARY_MODULE_ERROR.format(duplicateModules)
      )
    }

    return uniqueLibraryGlideModules
  }
}

/**
 * Generates an empty class with an annotation containing the class names of one or more
 * LibraryGlideModules and/or one or more GlideExtensions.
 *
 * We use a separate class so that LibraryGlideModules and GlideExtensions written in libraries can
 * be bundled into an AAR and later retrieved by the annotation processor when it processes the
 * AppGlideModule in an application.
 *
 * The output file generated by this class with a single LibraryGlideModule looks like this:
 *
 * ```
 * @com.bumptech.glide.annotation.ksp.Index(
 *   ["com.bumptech.glide.integration.okhttp3.OkHttpLibraryGlideModule"]
 * )
 * class Indexer_GlideModule_com_bumptech_glide_integration_okhttp3_OkHttpLibraryGlideModule
 * ```
 *
 * This class is not a public API and used only internally by the processor.
 */
internal object IndexGenerator {
  private const val INDEXER_NAME_PREFIX = "GlideIndexer_"
  private const val MAXIMUM_FILE_NAME_LENGTH = 255

  // The name of the parameter in the Index annotation that points to the list of modules
  internal const val INDEX_MODULES_NAME = "modules"

  @OptIn(DelicateKotlinPoetApi::class) // For AnnotationSpec.builder
  fun generate(
    libraryModuleNames: List<LibraryModuleName>,
  ): FileSpec {
    val libraryModuleQualifiedNames: List<String> = libraryModuleNames.map { it.qualifiedName }

    val indexAnnotation: AnnotationSpec =
      AnnotationSpec.builder(Index::class.java)
        .addRepeatedMember(INDEX_MODULES_NAME, libraryModuleQualifiedNames)
        .build()
    val indexName = generateUniqueName(libraryModuleQualifiedNames)

    return FileSpec.builder(GlideSymbolProcessorConstants.PACKAGE_NAME, indexName)
      .addType(TypeSpec.classBuilder(indexName).addAnnotation(indexAnnotation).build())
      .build()
  }

  private fun generateUniqueName(libraryModuleQualifiedNames: List<String>): String {
    val glideModuleBasedName = generateNameFromLibraryModules(libraryModuleQualifiedNames)

    // If the indexer name has too many packages/modules, it can exceed the file name length
    // allowed by the file system, which can break compilation. To avoid that, fall back to a
    // deterministic UUID.
    return if (glideModuleBasedName.exceedsFileSystemMaxNameLength()) {
      generateShortUUIDBasedName(glideModuleBasedName)
    } else {
      glideModuleBasedName
    }
  }

  private fun String.exceedsFileSystemMaxNameLength() =
    length >= MAXIMUM_FILE_NAME_LENGTH - INDEXER_NAME_PREFIX.length

  private fun generateShortUUIDBasedName(glideModuleBasedName: String) =
    INDEXER_NAME_PREFIX +
      UUID.nameUUIDFromBytes(glideModuleBasedName.toByteArray()).toString().replace("-", "_")

  private fun generateNameFromLibraryModules(libraryModuleQualifiedNames: List<String>): String {
    return libraryModuleQualifiedNames.joinToString(
      prefix = INDEXER_NAME_PREFIX + GlideModule::class.java.simpleName + "_",
      separator = "_"
    ) { it.replace(".", "_") }
  }

  private fun AnnotationSpec.Builder.addRepeatedMember(name: String, repeatedMember: List<String>) =
    addMember(
      "$name = [\n" + "%S,\n".repeat(repeatedMember.size) + "]", *repeatedMember.toTypedArray()
    )
}
